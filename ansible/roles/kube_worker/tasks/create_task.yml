---
# kube_worker — create or update a CloudflareTask CR for a single HTTPRoute.
# Contains all K8s-state decision logic that was previously in
# tenant_reconcile/tasks/reconcile_httproute.yml (Steps 0-3).
# The resulting CloudflareTask CR is consumed by cloudflare_worker.
#
# Variables (set by reconcile_tenant.yml):
#   - httproute: The HTTPRoute resource
#   - tenant_name / tenant_namespace / tenant_account_id / tenant_tunnel_id
#   - tenant_zone_id / tenant_credential_ref / tenant_defaults
#   - api_token: Cloudflare API token (for zone-id resolution only)
#   - cloudflare_api_base
#   - operator_namespace

# Step 0: Check if reconciliation is needed
- name: Check HTTPRoute state
  include_role:
    name: state_manager
    tasks_from: check_state.yml
  vars:
    httproute: "{{ httproute }}"
    operator_namespace: "{{ operator_namespace | default('cloudflare-zero-trust') }}"

- name: Skip if no changes detected
  ansible.builtin.debug:
    msg: "Skipping {{ httproute.metadata.namespace }}/{{ httproute.metadata.name }} – no changes detected"
  when: not needs_reconciliation

- name: Create CloudflareTask for changed HTTPRoute
  when: needs_reconciliation
  block:
    # Step 1: Extract HTTPRoute identity
    - name: Extract HTTPRoute metadata
      ansible.builtin.set_fact:
        ir_name: "{{ httproute.metadata.name }}"
        ir_namespace: "{{ httproute.metadata.namespace }}"
        ir_uid: "{{ httproute.metadata.uid }}"
        ir_annotations: "{{ httproute.metadata.annotations | default({}) }}"

    # Step 2: Load template
    - name: Get template name from annotation
      ansible.builtin.set_fact:
        template_name: "{{ ir_annotations.get('cfzt.cloudflare.com/template', 'default') }}"

    - name: Load CloudflareZeroTrustTemplate
      kubernetes.core.k8s_info:
        api_version: cfzt.cloudflare.com/v1alpha1
        kind: CloudflareZeroTrustTemplate
        name: "{{ template_name }}"
        namespace: "{{ ir_namespace }}"
      register: template_result

    - name: Validate template exists
      ansible.builtin.fail:
        msg: "Template '{{ template_name }}' not found in namespace {{ ir_namespace }}"
      when: template_result.resources | length == 0

    - name: Extract template spec
      ansible.builtin.set_fact:
        template_spec: "{{ template_result.resources[0].spec }}"

    - name: Detect dns-only mode
      ansible.builtin.set_fact:
        dns_only_mode: "{{ template_spec.dnsOnly.enabled | default(false) }}"

    # Step 3: Merge template+tenant settings into task-spec vars
    - name: Merge origin service settings
      ansible.builtin.set_fact:
        origin_service: "{{ template_spec.originService.url | default(tenant_defaults.originService | default('')) }}"
        http_redirect: "{{ template_spec.originService.httpRedirect | default(tenant_defaults.httpRedirect | default(true)) }}"

    - name: Merge origin TLS settings (template > tenant defaults)
      ansible.builtin.set_fact:
        no_tls_verify: "{{ template_spec.originService.originTLS.noTLSVerify | default(tenant_defaults.originTLS.noTLSVerify | default(false) if tenant_defaults.originTLS is defined else false) }}"
        origin_server_name: "{{ template_spec.originService.originTLS.originServerName | default(tenant_defaults.originTLS.originServerName | default('') if tenant_defaults.originTLS is defined else '') }}"
        ca_pool: "{{ template_spec.originService.originTLS.caPool | default(tenant_defaults.originTLS.caPool | default('') if tenant_defaults.originTLS is defined else '') }}"
        tls_timeout: "{{ template_spec.originService.originTLS.tlsTimeout | default(tenant_defaults.originTLS.tlsTimeout | default(10) if tenant_defaults.originTLS is defined else 10) | int }}"
        http2_origin: "{{ template_spec.originService.originTLS.http2Origin | default(tenant_defaults.originTLS.http2Origin | default(false) if tenant_defaults.originTLS is defined else false) }}"
        match_sni_to_host: "{{ template_spec.originService.originTLS.matchSNIToHost | default(tenant_defaults.originTLS.matchSNIToHost | default(false) if tenant_defaults.originTLS is defined else false) }}"
      when: template_spec.originService.originTLS is defined or tenant_defaults.originTLS is defined

    - name: Set default TLS settings when not in template or tenant
      ansible.builtin.set_fact:
        no_tls_verify: false
        origin_server_name: ""
        ca_pool: ""
        tls_timeout: 10
        http2_origin: false
        match_sni_to_host: false
      when: template_spec.originService.originTLS is not defined and tenant_defaults.originTLS is not defined

    - name: Merge Access Application settings
      ansible.builtin.set_fact:
        create_access_app: "{{ template_spec.accessApplication.enabled | default(false) }}"
        session_duration: "{{ template_spec.accessApplication.sessionDuration | default(tenant_defaults.sessionDuration | default('24h')) }}"
        allow_groups: "{{ template_spec.accessApplication.allowGroups | default([]) | join(',') }}"
        allow_emails: "{{ template_spec.accessApplication.allowEmails | default([]) | join(',') }}"
        existing_policy_ids: "{{ template_spec.accessApplication.existingPolicyIds | default([]) | join(',') }}"
        auto_redirect_to_identity: "{{ template_spec.accessApplication.autoRedirectToIdentity | default(false) }}"
        enable_binding_cookie: "{{ template_spec.accessApplication.enableBindingCookie | default(false) }}"
        http_only_cookie_attribute: "{{ template_spec.accessApplication.httpOnlyCookieAttribute | default(true) }}"
        same_site_cookie_attribute: "{{ template_spec.accessApplication.sameSiteCookieAttribute | default('lax') }}"
        logo_url: "{{ template_spec.accessApplication.logoUrl | default('') }}"
        skip_interstitial: "{{ template_spec.accessApplication.skipInterstitial | default(false) }}"
        app_launcher_visible: "{{ template_spec.accessApplication.appLauncherVisible | default(true) }}"
        service_auth_401_redirect: "{{ template_spec.accessApplication.serviceAuth401Redirect | default(false) }}"
        custom_deny_message: "{{ template_spec.accessApplication.customDenyMessage | default('') }}"
        custom_deny_url: "{{ template_spec.accessApplication.customDenyUrl | default('') }}"
        custom_non_identity_deny_url: "{{ template_spec.accessApplication.customNonIdentityDenyUrl | default('') }}"
      when: template_spec.accessApplication is defined

    - name: Set default Access Application settings
      ansible.builtin.set_fact:
        create_access_app: false
        session_duration: "{{ tenant_defaults.sessionDuration | default('24h') }}"
        allow_groups: ""
        allow_emails: ""
        existing_policy_ids: ""
        auto_redirect_to_identity: false
        enable_binding_cookie: false
        http_only_cookie_attribute: true
        same_site_cookie_attribute: "lax"
        logo_url: ""
        skip_interstitial: false
        app_launcher_visible: true
        service_auth_401_redirect: false
        custom_deny_message: ""
        custom_deny_url: ""
        custom_non_identity_deny_url: ""
      when: template_spec.accessApplication is not defined

    - name: Merge Service Token settings
      ansible.builtin.set_fact:
        create_service_token: "{{ template_spec.serviceToken.enabled | default(false) }}"
        service_token_duration: "{{ template_spec.serviceToken.duration | default('8760h') }}"
      when: template_spec.serviceToken is defined

    - name: Set default Service Token settings
      ansible.builtin.set_fact:
        create_service_token: false
        service_token_duration: "8760h"
      when: template_spec.serviceToken is not defined

    # Step 4: Parse core annotations
    - name: Parse hostname and existing CF resource IDs from annotations
      ansible.builtin.set_fact:
        hostname: "{{ ir_annotations['cfzt.cloudflare.com/hostname'] | default('') }}"
        tunnel_id: "{{ ir_annotations['cfzt.cloudflare.com/tunnelId'] | default(tenant_tunnel_id) }}"
        existing_app_id: "{{ ir_annotations['cfzt.cloudflare.com/accessAppId'] | default('') }}"
        existing_token_id: "{{ ir_annotations['cfzt.cloudflare.com/serviceTokenId'] | default('') }}"
        existing_cname_id: "{{ ir_annotations['cfzt.cloudflare.com/cnameRecordId'] | default('') }}"
        existing_dns_record_id: "{{ ir_annotations['cfzt.cloudflare.com/dnsRecordId'] | default('') }}"

    - name: Validate hostname annotation is present
      ansible.builtin.fail:
        msg: "HTTPRoute {{ ir_namespace }}/{{ ir_name }} is missing annotation cfzt.cloudflare.com/hostname"
      when: hostname == ""

    - name: Detect if origin service uses HTTPS
      ansible.builtin.set_fact:
        origin_uses_https: "{{ origin_service.startswith('https://') }}"

    # Step 5: Resolve Cloudflare Zone ID (read-only API call, kube_worker responsibility)
    - name: Auto-discover Zone ID for hostname
      include_role:
        name: cloudflare_api
        tasks_from: lookup_zone_id.yml
      vars:
        cf_api_token: "{{ api_token }}"
        cf_hostname: "{{ hostname }}"
        cf_api_base: "{{ cloudflare_api_base }}"
        cf_tenant_zone_id: "{{ tenant_zone_id | default('') }}"

    # Step 6: Resolve dns-only target IP into the task spec (also K8s-only work)
    - name: Resolve dns-only static IP from template
      ansible.builtin.set_fact:
        dns_target_ip: "{{ template_spec.dnsOnly.staticIp }}"
      when: dns_only_mode and template_spec.dnsOnly.staticIp is defined and template_spec.dnsOnly.staticIp | length > 0

    - name: Resolve dns-only IP from ingressServiceRef
      when: dns_only_mode and (template_spec.dnsOnly.staticIp is not defined or template_spec.dnsOnly.staticIp | default('') | length == 0)
      block:
        - name: Fail if neither staticIp nor ingressServiceRef provided
          ansible.builtin.fail:
            msg: "dnsOnly mode requires either staticIp or ingressServiceRef in template '{{ template_name }}'"
          when: template_spec.dnsOnly.ingressServiceRef is not defined

        - name: Look up LoadBalancer Service
          kubernetes.core.k8s_info:
            api_version: v1
            kind: Service
            name: "{{ template_spec.dnsOnly.ingressServiceRef.name }}"
            namespace: "{{ template_spec.dnsOnly.ingressServiceRef.namespace | default(ir_namespace) }}"
          register: ingress_svc_result

        - name: Fail if service not found
          ansible.builtin.fail:
            msg: >-
              Service {{ template_spec.dnsOnly.ingressServiceRef.namespace | default(ir_namespace) }}/
              {{ template_spec.dnsOnly.ingressServiceRef.name }} not found
          when: ingress_svc_result.resources | length == 0

        - name: Extract LoadBalancer IP
          ansible.builtin.set_fact:
            dns_target_ip: "{{ ingress_svc_result.resources[0].status.loadBalancer.ingress[0].ip }}"

        - name: Fail if no LoadBalancer IP assigned yet
          ansible.builtin.fail:
            msg: >-
              Service {{ template_spec.dnsOnly.ingressServiceRef.namespace | default(ir_namespace) }}/
              {{ template_spec.dnsOnly.ingressServiceRef.name }} has no LoadBalancer IP assigned yet
          when: dns_target_ip is not defined or dns_target_ip | length == 0

    - name: Default dns_target_ip when not in dns-only mode
      ansible.builtin.set_fact:
        dns_target_ip: ""
      when: not dns_only_mode

    # Step 7: Build and apply the CloudflareTask CR
    - name: Set CloudflareTask name
      ansible.builtin.set_fact:
        task_name: "cfzt-{{ ir_namespace }}-{{ ir_name }}"

    - name: Apply CloudflareTask CR
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: cfzt.cloudflare.com/v1alpha1
          kind: CloudflareTask
          metadata:
            name: "{{ task_name }}"
            namespace: "{{ operator_namespace | default('cloudflare-zero-trust') }}"
            labels:
              cfzt.cloudflare.com/httproute-name: "{{ ir_name }}"
              cfzt.cloudflare.com/httproute-namespace: "{{ ir_namespace }}"
              cfzt.cloudflare.com/tenant: "{{ tenant_name }}"
            annotations:
              cfzt.cloudflare.com/annotation-hash: "{{ current_annotation_hash }}"
          spec:
            httprouteRef:
              name: "{{ ir_name }}"
              namespace: "{{ ir_namespace }}"
              uid: "{{ ir_uid }}"
            tenantRef:
              name: "{{ tenant_name }}"
              namespace: "{{ tenant_namespace }}"
            credentialSecretRef:
              name: "{{ tenant_credential_ref.name }}"
              namespace: "{{ tenant_namespace }}"
              key: "{{ tenant_credential_ref.key | default('token') }}"
            hostname: "{{ hostname }}"
            accountId: "{{ tenant_account_id }}"
            tunnelId: "{{ tunnel_id }}"
            zoneId: "{{ resolved_zone_id | default('') }}"
            operations:
              tunnelRoute:
                enabled: "{{ not dns_only_mode }}"
                originService: "{{ origin_service }}"
                httpRedirect: "{{ http_redirect }}"
                originTLS:
                  noTLSVerify: "{{ no_tls_verify }}"
                  originServerName: "{{ origin_server_name }}"
                  caPool: "{{ ca_pool }}"
                  tlsTimeout: "{{ tls_timeout }}"
                  http2Origin: "{{ http2_origin }}"
                  matchSNIToHost: "{{ match_sni_to_host }}"
              cnameDns:
                enabled: "{{ not dns_only_mode and resolved_zone_id | default('') != '' }}"
              accessApp:
                enabled: "{{ create_access_app }}"
                sessionDuration: "{{ session_duration }}"
                allowGroups: "{{ allow_groups }}"
                allowEmails: "{{ allow_emails }}"
                existingPolicyIds: "{{ existing_policy_ids }}"
                autoRedirectToIdentity: "{{ auto_redirect_to_identity }}"
                enableBindingCookie: "{{ enable_binding_cookie }}"
                httpOnlyCookieAttribute: "{{ http_only_cookie_attribute }}"
                sameSiteCookieAttribute: "{{ same_site_cookie_attribute }}"
                logoUrl: "{{ logo_url }}"
                skipInterstitial: "{{ skip_interstitial }}"
                appLauncherVisible: "{{ app_launcher_visible }}"
                serviceAuth401Redirect: "{{ service_auth_401_redirect }}"
                customDenyMessage: "{{ custom_deny_message }}"
                customDenyUrl: "{{ custom_deny_url }}"
                customNonIdentityDenyUrl: "{{ custom_non_identity_deny_url }}"
              serviceToken:
                enabled: "{{ create_service_token }}"
                duration: "{{ service_token_duration }}"
                secretNamespace: "{{ ir_namespace }}"
              dnsRecord:
                enabled: "{{ dns_only_mode }}"
                ipAddress: "{{ dns_target_ip }}"
                proxied: "{{ template_spec.dnsOnly.proxied | default(false) }}"
                ttl: "{{ template_spec.dnsOnly.ttl | default(120) }}"
            existingIds:
              appId: "{{ existing_app_id }}"
              serviceTokenId: "{{ existing_token_id }}"
              cnameRecordId: "{{ existing_cname_id }}"
              dnsRecordId: "{{ existing_dns_record_id }}"
      register: task_apply_result

    - name: Reset task status to Pending when spec changed
      kubernetes.core.k8s:
        state: patched
        api_version: cfzt.cloudflare.com/v1alpha1
        kind: CloudflareTask
        name: "{{ task_name }}"
        namespace: "{{ operator_namespace | default('cloudflare-zero-trust') }}"
        definition:
          status:
            phase: Pending
            message: "Queued by kube_worker"
            workerPod: ""
      when: task_apply_result.changed

    - name: Display task queued
      ansible.builtin.debug:
        msg: "CloudflareTask {{ task_name }} queued for cloudflare_worker"
      when: task_apply_result.changed
