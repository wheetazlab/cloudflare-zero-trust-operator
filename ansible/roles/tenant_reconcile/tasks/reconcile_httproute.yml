---
# Reconcile a single HTTPRoute
# Variables:
#   - httproute: The HTTPRoute resource
#   - api_token: Cloudflare API token
#   - tenant_account_id: Account ID
#   - tenant_tunnel_id: Default tunnel ID
#   - tenant_defaults: Default values
#   - operator_namespace: Operator namespace (default: cloudflare-zero-trust)

# Step 0: Check if reconciliation needed based on state
- name: Check HTTPRoute state
  include_role:
    name: state_manager
    tasks_from: check_state.yml
  vars:
    httproute: "{{ httproute }}"
    operator_namespace: "{{ operator_namespace | default('cloudflare-zero-trust') }}"

- name: Skip reconciliation if no changes detected
  ansible.builtin.debug:
    msg: "Skipping {{ httproute.metadata.namespace }}/{{ httproute.metadata.name }} - no changes detected"
  when: not needs_reconciliation

- name: Reconcile HTTPRoute (changed or new)
  when: needs_reconciliation
  block:
    - name: Extract HTTPRoute metadata
      ansible.builtin.set_fact:
        ir_name: "{{ httproute.metadata.name }}"
        ir_namespace: "{{ httproute.metadata.namespace }}"
        ir_uid: "{{ httproute.metadata.uid }}"
        ir_annotations: "{{ httproute.metadata.annotations }}"

    # Step 1: Load template
    - name: Get template name from annotation or use default
      ansible.builtin.set_fact:
        template_name: "{{ ir_annotations.get('cfzt.cloudflare.com/template', 'default') }}"

    - name: Load CloudflareZeroTrustTemplate
      kubernetes.core.k8s_info:
        api_version: cfzt.cloudflare.com/v1alpha1
        kind: CloudflareZeroTrustTemplate
        name: "{{ template_name }}"
        namespace: "{{ ir_namespace }}"
      register: template_result

    - name: Validate template exists
      ansible.builtin.fail:
        msg: "Template '{{ template_name }}' not found in namespace {{ ir_namespace }}"
      when: template_result.resources | length == 0

    - name: Extract template spec
      ansible.builtin.set_fact:
        template_spec: "{{ template_result.resources[0].spec }}"

    # Step 2: Merge template with tenant defaults (template takes precedence)
    - name: Merge origin service settings (template > tenant defaults)
      ansible.builtin.set_fact:
        origin_service: "{{ template_spec.originService.url | default(tenant_defaults.originService | default('http://traefik.traefik.svc:80')) }}"
        http_redirect: "{{ template_spec.originService.httpRedirect | default(tenant_defaults.httpRedirect | default(true)) }}"

    - name: Merge origin TLS settings (template > tenant defaults)
      ansible.builtin.set_fact:
        no_tls_verify: "{{ template_spec.originService.originTLS.noTLSVerify | default(tenant_defaults.originTLS.noTLSVerify | default(false) if tenant_defaults.originTLS is defined else false) }}"
        origin_server_name: "{{ template_spec.originService.originTLS.originServerName | default(tenant_defaults.originTLS.originServerName | default('') if tenant_defaults.originTLS is defined else '') }}"
        ca_pool: "{{ template_spec.originService.originTLS.caPool | default(tenant_defaults.originTLS.caPool | default('') if tenant_defaults.originTLS is defined else '') }}"
        tls_timeout: "{{ template_spec.originService.originTLS.tlsTimeout | default(tenant_defaults.originTLS.tlsTimeout | default(10) if tenant_defaults.originTLS is defined else 10) | int }}"
        http2_origin: "{{ template_spec.originService.originTLS.http2Origin | default(tenant_defaults.originTLS.http2Origin | default(false) if tenant_defaults.originTLS is defined else false) }}"
        match_sni_to_host: "{{ template_spec.originService.originTLS.matchSNIToHost | default(tenant_defaults.originTLS.matchSNIToHost | default(false) if tenant_defaults.originTLS is defined else false) }}"
      when: template_spec.originService.originTLS is defined or tenant_defaults.originTLS is defined

    - name: Set default TLS settings if not in template or tenant
      ansible.builtin.set_fact:
        no_tls_verify: false
        origin_server_name: ""
        ca_pool: ""
        tls_timeout: 10
        http2_origin: false
        match_sni_to_host: false
      when: template_spec.originService.originTLS is not defined and tenant_defaults.originTLS is not defined

    - name: Merge Access Application settings (template > tenant defaults)
      ansible.builtin.set_fact:
        create_access_app: "{{ template_spec.accessApplication.enabled | default(false) }}"
        session_duration: "{{ template_spec.accessApplication.sessionDuration | default(tenant_defaults.sessionDuration | default('24h')) }}"
        allow_groups: "{{ template_spec.accessApplication.allowGroups | default([]) | join(',') }}"
        allow_emails: "{{ template_spec.accessApplication.allowEmails | default([]) | join(',') }}"
        existing_policy_ids: "{{ template_spec.accessApplication.existingPolicyIds | default([]) | join(',') }}"
        # Access Application settings
        auto_redirect_to_identity: "{{ template_spec.accessApplication.autoRedirectToIdentity | default(false) }}"
        enable_binding_cookie: "{{ template_spec.accessApplication.enableBindingCookie | default(false) }}"
        http_only_cookie_attribute: "{{ template_spec.accessApplication.httpOnlyCookieAttribute | default(true) }}"
        same_site_cookie_attribute: "{{ template_spec.accessApplication.sameSiteCookieAttribute | default('lax') }}"
        logo_url: "{{ template_spec.accessApplication.logoUrl | default('') }}"
        skip_interstitial: "{{ template_spec.accessApplication.skipInterstitial | default(false) }}"
        app_launcher_visible: "{{ template_spec.accessApplication.appLauncherVisible | default(true) }}"
        service_auth_401_redirect: "{{ template_spec.accessApplication.serviceAuth401Redirect | default(false) }}"
        custom_deny_message: "{{ template_spec.accessApplication.customDenyMessage | default('') }}"
        custom_deny_url: "{{ template_spec.accessApplication.customDenyUrl | default('') }}"
        custom_non_identity_deny_url: "{{ template_spec.accessApplication.customNonIdentityDenyUrl | default('') }}"
      when: template_spec.accessApplication is defined

    - name: Set default Access Application settings if not in template
      ansible.builtin.set_fact:
        create_access_app: false
        session_duration: "{{ tenant_defaults.sessionDuration | default('24h') }}"
        allow_groups: ""
        allow_emails: ""
        existing_policy_ids: ""
        auto_redirect_to_identity: false
        enable_binding_cookie: false
        http_only_cookie_attribute: true
        same_site_cookie_attribute: "lax"
        logo_url: ""
        skip_interstitial: false
        app_launcher_visible: true
        service_auth_401_redirect: false
        custom_deny_message: ""
        custom_deny_url: ""
        custom_non_identity_deny_url: ""
      when: template_spec.accessApplication is not defined

    - name: Merge Service Token settings (template > tenant defaults)
      ansible.builtin.set_fact:
        create_service_token: "{{ template_spec.serviceToken.enabled | default(false) }}"
        service_token_duration: "{{ template_spec.serviceToken.duration | default('8760h') }}"
      when: template_spec.serviceToken is defined

    - name: Set default Service Token settings if not in template
      ansible.builtin.set_fact:
        create_service_token: false
        service_token_duration: "8760h"
      when: template_spec.serviceToken is not defined

    # Step 3: Parse core annotations (hostname, tunnel ID, etc.)
    - name: Parse core HTTPRoute annotations
      ansible.builtin.set_fact:
        hostname: "{{ ir_annotations['cfzt.cloudflare.com/hostname'] | default('') }}"
        tunnel_id: "{{ ir_annotations['cfzt.cloudflare.com/tunnelId'] | default(tenant_tunnel_id) }}"
        # Get existing resource IDs for updates
        existing_app_id: "{{ ir_annotations['cfzt.cloudflare.com/accessAppId'] | default('') }}"
        existing_token_id: "{{ ir_annotations['cfzt.cloudflare.com/serviceTokenId'] | default('') }}"
        existing_route_id: "{{ ir_annotations['cfzt.cloudflare.com/hostnameRouteId'] | default('') }}"

    - name: Detect if origin service uses HTTPS
      ansible.builtin.set_fact:
        origin_uses_https: "{{ origin_service.startswith('https://') }}"

    - name: Initialize Cloudflare IDs dictionary
      ansible.builtin.set_fact:
        cloudflare_resource_ids: {}

    - name: Validate hostname
      ansible.builtin.fail:
        msg: "HTTPRoute {{ ir_namespace }}/{{ ir_name }} missing required annotation: cfzt.cloudflare.com/hostname"
      when: hostname == ""

    - name: Display reconciliation details
      ansible.builtin.debug:
        msg: "Reconciling HTTPRoute {{ ir_namespace }}/{{ ir_name }} - hostname: {{ hostname }}"

    # Step 1: Create/Update Hostname Route
    - name: Manage hostname route
      include_role:
        name: cloudflare_api
        tasks_from: manage_hostname_route.yml
      vars:
        cf_api_token: "{{ api_token }}"
        cf_account_id: "{{ tenant_account_id }}"
        cf_tunnel_id: "{{ tunnel_id }}"
        cf_hostname: "{{ hostname }}"
        cf_origin_service: "{{ origin_service }}"
        cf_api_base: "{{ cloudflare_api_base }}"
        # TLS configuration
        cf_origin_uses_https: "{{ origin_uses_https }}"
        cf_http_redirect: "{{ http_redirect }}"
        cf_no_tls_verify: "{{ no_tls_verify }}"
        cf_origin_server_name: "{{ origin_server_name }}"
        cf_ca_pool: "{{ ca_pool }}"
        cf_tls_timeout: "{{ tls_timeout }}"
        cf_http2_origin: "{{ http2_origin }}"
        cf_match_sni_to_host: "{{ match_sni_to_host }}"

    - name: Store hostname route ID
      ansible.builtin.set_fact:
        cloudflare_resource_ids: "{{ cloudflare_resource_ids | combine({'tunnel_id': tunnel_id, 'hostname': hostname}) }}"

    - name: Increment hostname route counter
      ansible.builtin.set_fact:
        count_hostname_routes: "{{ count_hostname_routes | int + 1 }}"

    # Step 2: Create/Update Access Application (if enabled)
    - name: Manage Access Application
      block:
        - name: Create/Update Access Application
          include_role:
            name: cloudflare_api
            tasks_from: manage_access_app.yml
          vars:
            cf_api_token: "{{ api_token }}"
            cf_account_id: "{{ tenant_account_id }}"
            cf_app_name: "{{ ir_name }}"
            cf_app_domain: "{{ hostname }}"
            cf_app_id: "{{ existing_app_id }}"
            cf_session_duration: "{{ session_duration }}"
            cf_api_base: "{{ cloudflare_api_base }}"
            # Template settings
            cf_auto_redirect_to_identity: "{{ auto_redirect_to_identity }}"
            cf_enable_binding_cookie: "{{ enable_binding_cookie }}"
            cf_http_only_cookie_attribute: "{{ http_only_cookie_attribute }}"
            cf_same_site_cookie_attribute: "{{ same_site_cookie_attribute }}"
            cf_logo_url: "{{ logo_url }}"
            cf_skip_interstitial: "{{ skip_interstitial }}"
            cf_app_launcher_visible: "{{ app_launcher_visible }}"
            cf_service_auth_401_redirect: "{{ service_auth_401_redirect }}"
            cf_custom_deny_message: "{{ custom_deny_message }}"
            cf_custom_deny_url: "{{ custom_deny_url }}"
            cf_custom_non_identity_deny_url: "{{ custom_non_identity_deny_url }}"

        - name: Store access app ID
          ansible.builtin.set_fact:
            cloudflare_resource_ids: "{{ cloudflare_resource_ids | combine({'access_app_id': access_app_result.app_id}) }}"

        - name: Increment access app counter
          ansible.builtin.set_fact:
            count_access_apps: "{{ count_access_apps | int + 1 }}"

        # Step 3: Handle Access Policies
        - name: Determine if using existing policies
          ansible.builtin.set_fact:
            use_existing_policies: "{{ existing_policy_ids | length > 0 }}"

        # Option A: Use existing policies (template has existingPolicyIds)
        - name: Use existing policies from template
          block:
            - name: Parse existing policy IDs
              ansible.builtin.set_fact:
                existing_policy_list: "{{ existing_policy_ids.split(',') | map('trim') | list }}"

            - name: Display existing policies being used
              ansible.builtin.debug:
                msg: "Using {{ existing_policy_list | length }} existing policies for {{ ir_name }}"

            - name: Store policy IDs in annotations
              ansible.builtin.set_fact:
                cloudflare_resource_ids: "{{ cloudflare_resource_ids | combine({'access_policy_ids': existing_policy_ids}) }}"

          when: use_existing_policies

        # Option B: Create/Update Policy (backward compatible)
        - name: Create/Update Access Policy
          block:
            - name: Parse allow groups
              ansible.builtin.set_fact:
                allow_groups_list: "{{ allow_groups.split(',') | map('trim') | list }}"
              when: allow_groups | length > 0

            - name: Parse allow emails
              ansible.builtin.set_fact:
                allow_emails_list: "{{ allow_emails.split(',') | map('trim') | list }}"
              when: allow_emails | length > 0

            - name: Create/Update Access Policy
              include_role:
                name: cloudflare_api
                tasks_from: manage_access_policy.yml
              vars:
                cf_api_token: "{{ api_token }}"
                cf_account_id: "{{ tenant_account_id }}"
                cf_app_id: "{{ access_app_result.app_id }}"
                cf_policy_name: "{{ ir_name }}-allow-policy"
                cf_allow_groups: "{{ allow_groups_list | default([]) }}"
                cf_allow_emails: "{{ allow_emails_list | default([]) }}"
                cf_policy_id: ""  # Always create new policy
                cf_api_base: "{{ cloudflare_api_base }}"

            - name: Store access policy ID
              ansible.builtin.set_fact:
                cloudflare_resource_ids: "{{ cloudflare_resource_ids | combine({'access_policy_id': access_policy_result.policy_id}) }}"

            - name: Increment access policy counter
              ansible.builtin.set_fact:
                count_access_policies: "{{ count_access_policies | int + 1 }}"

          when: not use_existing_policies

        # Update HTTPRoute with Access App and Policy IDs
        - name: Patch HTTPRoute with Access IDs (existing policies)
          kubernetes.core.k8s:
            state: patched
            kind: HTTPRoute
            api_version: gateway.networking.k8s.io/v1
            name: "{{ ir_name }}"
            namespace: "{{ ir_namespace }}"
            definition:
              metadata:
                annotations:
                  cfzt.cloudflare.com/accessAppId: "{{ access_app_result.app_id }}"
                  cfzt.cloudflare.com/accessPolicyIds: "{{ existing_policy_ids }}"
          when: use_existing_policies

        - name: Patch HTTPRoute with Access IDs (created policy)
          kubernetes.core.k8s:
            state: patched
            kind: HTTPRoute
            api_version: gateway.networking.k8s.io/v1
            name: "{{ ir_name }}"
            namespace: "{{ ir_namespace }}"
            definition:
              metadata:
                annotations:
                  cfzt.cloudflare.com/accessAppId: "{{ access_app_result.app_id }}"
                  cfzt.cloudflare.com/accessPolicyIds: "{{ access_policy_result.policy_id }}"
          when: not use_existing_policies

      when: create_access_app

    # Step 4: Create Service Token (if enabled)
    - name: Manage Service Token
      block:
        - name: Create Service Token
          include_role:
            name: cloudflare_api
            tasks_from: manage_service_token.yml
          vars:
            cf_api_token: "{{ api_token }}"
            cf_account_id: "{{ tenant_account_id }}"
            cf_token_name: "{{ ir_name }}-service-token"
            cf_token_id: "{{ existing_token_id }}"
            cf_api_base: "{{ cloudflare_api_base }}"

        - name: Store service token ID
          ansible.builtin.set_fact:
            cloudflare_resource_ids: "{{ cloudflare_resource_ids | combine({'service_token_id': service_token_result.token_id}) }}"

        - name: Increment service token counter
          ansible.builtin.set_fact:
            count_service_tokens: "{{ count_service_tokens | int + 1 }}"

        # Create K8s Secret with token credentials (only on creation)
        - name: Create Kubernetes Secret for Service Token
          kubernetes.core.k8s:
            state: present
            definition:
              apiVersion: v1
              kind: Secret
              metadata:
                name: "{{ ir_name }}-cfzt-service-token"
                namespace: "{{ ir_namespace }}"
              type: Opaque
              stringData:
                client_id: "{{ service_token_result.client_id }}"
                client_secret: "{{ service_token_result.client_secret }}"
          when: service_token_result.created

        # Update HTTPRoute with Service Token ID and Secret name
        - name: Patch HTTPRoute with Service Token info
          kubernetes.core.k8s:
            state: patched
            kind: HTTPRoute
            api_version: gateway.networking.k8s.io/v1
            name: "{{ ir_name }}"
            namespace: "{{ ir_namespace }}"
            definition:
              metadata:
                annotations:
                  cfzt.cloudflare.com/serviceTokenId: "{{ service_token_result.token_id }}"
                  cfzt.cloudflare.com/serviceTokenSecretName: "{{ ir_name }}-cfzt-service-token"

      when: create_service_token

    # Final: Update HTTPRoute with hostname route info
    - name: Patch HTTPRoute with hostname route info
      kubernetes.core.k8s:
        state: patched
        kind: HTTPRoute
        api_version: gateway.networking.k8s.io/v1
        name: "{{ ir_name }}"
        namespace: "{{ ir_namespace }}"
        definition:
          metadata:
            annotations:
              cfzt.cloudflare.com/hostnameRouteId: "{{ tunnel_id }}"
              cfzt.cloudflare.com/lastReconcile: "{{ ansible_date_time.iso8601 }}"

    # Update state ConfigMap with reconciliation results
    - name: Update HTTPRoute state
      include_role:
        name: state_manager
        tasks_from: update_state.yml
      vars:
        state_configmap_name: "{{ state_configmap_name }}"
        ir_name: "{{ ir_name }}"
        ir_namespace: "{{ ir_namespace }}"
        ir_uid: "{{ ir_uid }}"
        current_annotation_hash: "{{ current_annotation_hash }}"
        cloudflare_ids: "{{ cloudflare_resource_ids }}"
        operator_namespace: "{{ operator_namespace | default('cloudflare-zero-trust') }}"
